import { execSync } from 'child_process';
import { existsSync, mkdirSync, copyFileSync } from 'fs';
import { join, resolve } from 'path';
import { getComposeCacheDirectory, detectProfileAndSshKey, getPathHash } from '../cli';

export function handleExportCommand(args: string[]): void {
  try {
    // Parse export arguments
    if (args.length < 3) {
      console.error('Error: vcr export requires exactly 2 arguments: <profile> <path>');
      console.log('Usage: vcr export <profile> <path>');
      console.log('Examples:');
      console.log('  vcr export prod ./my-prod-deployment');
      console.log('  vcr export stage-release ./stage-artifacts');
      console.log('  vcr export prod-debug ./debug-deployment');
      process.exit(1);
    }

    const profile = args[1];
    const exportPath = resolve(args[2]);

    // Validate profile
    const validProfiles = ['stage', 'stage-release', 'prod', 'prod-debug'];
    if (!validProfiles.includes(profile)) {
      console.error(`Error: Invalid profile '${profile}'. Valid profiles: ${validProfiles.join(', ')}`);
      process.exit(1);
    }

    console.log(`üì¶ Exporting ${profile} profile to: ${exportPath}`);

    // Create export directory
    if (!existsSync(exportPath)) {
      mkdirSync(exportPath, { recursive: true });
      console.log(`‚úÖ Created export directory: ${exportPath}`);
    }

    // Get cache directory
    const pathHash = getPathHash();
    const cacheDir = getComposeCacheDirectory();
    
    // Determine debug suffix for file names
    const includeDebugTools = profile === 'stage' || profile === 'prod-debug';
    const debugSuffix = includeDebugTools ? '-debug' : '-release';

    // Export files based on profile
    const exportedFiles: string[] = [];

    if (profile === 'stage' || profile === 'stage-release') {
      // Export QEMU-based profile files
      const qemuKernel = join(cacheDir, `vc${debugSuffix}.qemu-kernel`);
      const squashfs = join(cacheDir, `vc${debugSuffix}.squashfs`);

      if (!existsSync(qemuKernel)) {
        console.error(`‚ùå Error: QEMU kernel not found: ${qemuKernel}`);
        console.error('Run "vcr build ' + profile + '" first to create the required files.');
        process.exit(1);
      }

      if (!existsSync(squashfs)) {
        console.error(`‚ùå Error: Squashfs not found: ${squashfs}`);
        console.error('Run "vcr build ' + profile + '" first to create the required files.');
        process.exit(1);
      }

      // Copy QEMU kernel
      const exportedKernel = join(exportPath, 'vc.qemu-kernel');
      copyFileSync(qemuKernel, exportedKernel);
      exportedFiles.push('vc.qemu-kernel');

      // Copy squashfs
      const exportedSquashfs = join(exportPath, 'vc.squashfs');
      copyFileSync(squashfs, exportedSquashfs);
      exportedFiles.push('vc.squashfs');

      // Create run script
      const runScript = `#!/bin/bash
# VCR ${profile} Profile Runner
# Generated by: vcr export ${profile}

set -e

echo "üöÄ Starting VCR ${profile} environment..."

# Check for required files
if [ ! -f "vc.qemu-kernel" ]; then
    echo "‚ùå Error: vc.qemu-kernel not found"
    exit 1
fi

if [ ! -f "vc.squashfs" ]; then
    echo "‚ùå Error: vc.squashfs not found"
    exit 1
fi

# Load vsock modules if not already loaded
sudo modprobe vsock_loopback 2>/dev/null || true
sudo modprobe vhost_vsock 2>/dev/null || true

# Start vhost-device-vsock
echo "üîß Starting vhost-device-vsock..."
RUST_LOG=info vhost-device-vsock --guest-cid=4 --forward-cid=1 --forward-listen=8080+8022 --socket=/tmp/vhost.socket --tx-buffer-size=65536 --queue-size=1024 &
VHOST_PID=$!

# Start socat forwarders
echo "üîó Starting port forwarders..."
socat tcp-listen:8080,fork VSOCK-CONNECT:1:8080 &
SOCAT_8080_PID=$!
socat tcp-listen:8022,fork VSOCK-CONNECT:1:8022 &
SOCAT_8022_PID=$!

# Wait a moment for services to start
sleep 1

echo "üê≥ Starting QEMU VM..."
qemu-system-riscv64 \\
  --machine virt,memory-backend=mem0 \\
  --kernel vc.qemu-kernel \\
  -nographic \\
  -object memory-backend-memfd,id=mem0,size=512M \\
  -append "root=/dev/vda rootfstype=squashfs console=ttyS0" \\
  -drive "file=vc.squashfs,format=raw,if=virtio" \\
  -chardev socket,id=c,path=/tmp/vhost.socket \\
  -device vhost-user-vsock-pci,chardev=c \\
  -monitor none \\
  -serial stdio

echo "üõë Cleaning up..."
kill $VHOST_PID $SOCAT_8080_PID $SOCAT_8022_PID 2>/dev/null || true
rm -f /tmp/vhost.socket
`;

      const runScriptPath = join(exportPath, 'run.sh');
      require('fs').writeFileSync(runScriptPath, runScript);
      require('fs').chmodSync(runScriptPath, 0o755);
      exportedFiles.push('run.sh');

    } else if (profile === 'prod' || profile === 'prod-debug') {
      // Export Cartesi Machine profile files
      const cmSquashfs = join(cacheDir, `vc-cm-snapshot${debugSuffix}.squashfs`);
      const rootHashFile = join(cacheDir, `vc-cm-snapshot${debugSuffix}.squashfs.root-hash`);

      if (!existsSync(cmSquashfs)) {
        console.error(`‚ùå Error: Cartesi machine squashfs not found: ${cmSquashfs}`);
        console.error('Run "vcr build ' + profile + '" first to create the required files.');
        process.exit(1);
      }

      if (!existsSync(rootHashFile)) {
        console.error(`‚ùå Error: Root hash file not found: ${rootHashFile}`);
        console.error('Run "vcr build ' + profile + '" first to create the required files.');
        process.exit(1);
      }

      // Copy Cartesi machine squashfs
      const exportedCmSquashfs = join(exportPath, 'vc-cm-snapshot.squashfs');
      copyFileSync(cmSquashfs, exportedCmSquashfs);
      exportedFiles.push('vc-cm-snapshot.squashfs');



      // Copy root hash file
      const exportedRootHash = join(exportPath, 'vc-cm-snapshot.squashfs.root-hash');
      copyFileSync(rootHashFile, exportedRootHash);
      exportedFiles.push('vc-cm-snapshot.squashfs.root-hash');

      // Create run script
      const runScript = `#!/bin/bash
# VCR ${profile} Profile Runner (Cartesi Machine)
# Generated by: vcr export ${profile}

set -e

echo "üöÄ Starting VCR ${profile} environment (Cartesi Machine)..."

# Check for required files
if [ ! -f "vc-cm-snapshot.squashfs" ]; then
    echo "‚ùå Error: vc-cm-snapshot.squashfs not found"
    exit 1
fi



if [ ! -f "vc-cm-snapshot.squashfs.root-hash" ]; then
    echo "‚ùå Error: vc-cm-snapshot.squashfs.root-hash not found"
    exit 1
fi

echo "üîê Starting Cartesi Machine with verity verification..."
cartesi-machine \\
  --flash-drive=label:root,filename:vc-cm-snapshot.squashfs \\
  --ram-length=1024Mi \\
  --append-bootargs="loglevel=8 init=/sbin/init systemd.unified_cgroup_hierarchy=0 ro" \\
  --skip-root-hash-check \\
  --virtio-net=user \\
  -p=0.0.0.0:8080:10.0.2.15:8080/tcp \\
  -p=0.0.0.0:8022:10.0.2.15:22/tcp \\
  -i

echo "üõë Cartesi Machine stopped"
`;

      const runScriptPath = join(exportPath, 'run.sh');
      require('fs').writeFileSync(runScriptPath, runScript);
      require('fs').chmodSync(runScriptPath, 0o755);
      exportedFiles.push('run.sh');
    }

    // Export debug SSH key if profile has debug tools
    if (includeDebugTools) {
      const sshKeyPath = join(cacheDir, 'ssh.debug-key');
      const sshKeyPubPath = join(cacheDir, 'ssh.debug-key.pub');

      if (existsSync(sshKeyPath)) {
        const exportedSshKey = join(exportPath, 'ssh.debug-key');
        copyFileSync(sshKeyPath, exportedSshKey);
        require('fs').chmodSync(exportedSshKey, 0o600);
        exportedFiles.push('ssh.debug-key');
      }

      if (existsSync(sshKeyPubPath)) {
        const exportedSshKeyPub = join(exportPath, 'ssh.debug-key.pub');
        copyFileSync(sshKeyPubPath, exportedSshKeyPub);
        exportedFiles.push('ssh.debug-key.pub');
      }

      // Create debug info file
             const debugInfo = `# VCR ${profile} Debug Information

This profile includes debug tools and SSH access.

## SSH Access
- Private key: ssh.debug-key
- Public key: ssh.debug-key.pub
- SSH port: 8022
- Username: root

## Connection Examples
\`\`\`bash
# Connect to VM shell
ssh -i ssh.debug-key -p 8022 root@localhost

# Execute command in container
ssh -i ssh.debug-key -p 8022 root@localhost "ctr -n services.linuxkit task exec --exec-id debug app <command>"

# View application logs
ssh -i ssh.debug-key -p 8022 root@localhost "cat /var/log/app.log"
\`\`\`

## File Structure
- run.sh: Main execution script
- ssh.debug-key: SSH private key for debug access
- ssh.debug-key.pub: SSH public key
${profile === 'stage' || profile === 'prod-debug' ? '- vc.qemu-kernel: QEMU kernel image\n- vc.squashfs: Root filesystem image' : '- vc-cm-snapshot.squashfs: Cartesi machine snapshot (includes verity hash tree)\n- vc-cm-snapshot.squashfs.root-hash: Root hash for verification'}
`;

      const debugInfoPath = join(exportPath, 'DEBUG.md');
      require('fs').writeFileSync(debugInfoPath, debugInfo);
      exportedFiles.push('DEBUG.md');
    }

    // Create README
    const readme = `# VCR ${profile} Profile Export

This directory contains all files needed to run the VCR ${profile} profile.

## Quick Start

\`\`\`bash
# Make run script executable (if not already)
chmod +x run.sh

# Start the environment
./run.sh
\`\`\`

## Requirements

${profile === 'stage' || profile === 'stage-release' ? '- QEMU with RISC-V support\n- vhost-device-vsock\n- socat' : '- Cartesi Machine emulator\n- cryptsetup (for verity verification)'}

## Files

${exportedFiles.map(file => `- \`${file}\`: ${getFileDescription(file, profile)}`).join('\n')}

## Usage

1. Ensure all requirements are installed
2. Run \`./run.sh\` to start the environment
3. Access the application at \`http://localhost:8080\`
${includeDebugTools ? '\n4. For debug access, use the SSH keys provided' : ''}

## Troubleshooting

- If the run script fails, check that all required files are present
- Ensure vsock modules are loaded: \`sudo modprobe vsock_loopback vhost_vsock\`
- Check system logs for detailed error messages

Generated by: vcr export ${profile}
`;

    const readmePath = join(exportPath, 'README.md');
    require('fs').writeFileSync(readmePath, readme);

    console.log(`‚úÖ Successfully exported ${profile} profile to: ${exportPath}`);
    console.log(`üìÅ Exported files:`);
    exportedFiles.forEach(file => console.log(`   - ${file}`));
    console.log(`   - README.md`);
    console.log('');
    console.log(`üöÄ To run: cd ${exportPath} && ./run.sh`);

  } catch (err) {
    console.error('Error exporting profile:', err);
    process.exit(1);
  }
}

function getFileDescription(filename: string, profile: string): string {
  switch (filename) {
    case 'run.sh':
      return 'Main execution script';
    case 'ssh.debug-key':
      return 'SSH private key for debug access';
    case 'ssh.debug-key.pub':
      return 'SSH public key';
    case 'vc.qemu-kernel':
      return 'QEMU kernel image';
    case 'vc.squashfs':
      return 'Root filesystem image';
    case 'vc-cm-snapshot.squashfs':
      return 'Cartesi machine snapshot';

    case 'vc-cm-snapshot.squashfs.root-hash':
      return 'Root hash for verity verification';
    case 'DEBUG.md':
      return 'Debug access instructions';
    default:
      return 'Profile-specific file';
  }
} 